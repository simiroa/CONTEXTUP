import sys
from pathlib import Path
import customtkinter as ctk
from tkinter import messagebox
from PIL import Image, ImageTk
import threading
import json
import time

# Add src to path
current_dir = Path(__file__).resolve().parent
src_dir = current_dir.parent.parent # features/image -> src
if str(src_dir) not in sys.path:
    sys.path.append(str(src_dir))

from utils.gui_lib import BaseWindow, PremiumScrollableFrame
from utils.i18n import t
from core.paths import CONFIG_DIR
from features.image.noise_master.engine import NoiseEngine
import numpy as np

try:
    import OpenEXR
    import Imath
    import array
except ImportError:
    OpenEXR = None

class LayerItem(ctk.CTkFrame):
    def __init__(self, master, layer_data, on_change, on_delete, index):
        super().__init__(master, fg_color="#2b2b2b", corner_radius=6)
        self.layer_data = layer_data
        self.on_change = on_change
        self.on_delete = on_delete
        self.index = index
        
        # Grid Layout for Item
        self.grid_columnconfigure(1, weight=1)
        
        # Visible
        self.var_visible = ctk.BooleanVar(value=layer_data.get('visible', True))
        self.chk_vis = ctk.CTkCheckBox(self, text="", width=24, variable=self.var_visible, command=self._update_data)
        self.chk_vis.grid(row=0, column=0, padx=(5,0), pady=8)
        
        # Name
        self.lbl_name = ctk.CTkLabel(self, text=layer_data.get('name', f'Layer {index}'), anchor="w", font=("", 12, "bold"))
        self.lbl_name.grid(row=0, column=1, padx=5, sticky="ew")
        
        # Blend Mode
        self.blend_var = ctk.StringVar(value=layer_data.get('blend_mode', 'add'))
        self.opt_blend = ctk.CTkOptionMenu(self, values=["normal", "add", "multiply", "subtract", "overlay"], 
                                         variable=self.blend_var, width=70, height=20, font=("", 11), command=self._update_data)
        self.opt_blend.grid(row=0, column=2, padx=5)
        
        # Delete
        self.btn_del = ctk.CTkButton(self, text="‚úï", width=24, height=24, fg_color="transparent", hover_color="#c0392b", command=lambda: on_delete(index))
        self.btn_del.grid(row=0, column=3, padx=5)
        
        # Bind Click
        self.bind("<Button-1>", lambda e: on_change(index, selected=True))
        self.lbl_name.bind("<Button-1>", lambda e: on_change(index, selected=True))
            
    def _update_data(self, *args):
        self.layer_data['visible'] = self.var_visible.get()
        self.layer_data['blend_mode'] = self.blend_var.get()
        self.on_change(self.index)
        
    def set_selected(self, selected):
        self.configure(fg_color="#404040" if selected else "#2b2b2b")

class NoiseMasterWindow(BaseWindow):
    def __init__(self):
        super().__init__(title="Noise Master", width=1300, height=850, icon_name="noise_master")
        
        self.engine = NoiseEngine(256, 256)
        self.layers = [
            {'name': 'Base Noise', 'type': 'perlin', 'scale_x': 4.0, 'scale_y': 4.0, 'octaves': 4, 'persistence': 0.5, 'visible': True, 'blend_mode': 'normal', 'seed': 123}
        ]
        self.selected_layer_index = 0
        self.preview_buffer = None
        self.normal_mode = False 
        self.debounce_timer = None
        self.var_link_scale = ctk.BooleanVar(value=True)

        self.create_ui()
        self.refresh_layer_list()
        self.update_properties_panel()
        self.request_render()

    def create_ui(self):
        # Main Layout: 3 Columns
        self.main_frame.grid_columnconfigure(1, weight=1)
        self.main_frame.grid_rowconfigure(0, weight=1)
        
        # --- LEFT PANEL: Layers ---
        self.frame_layers = ctk.CTkFrame(self.main_frame, width=280)
        self.frame_layers.grid(row=0, column=0, sticky="ns", padx=5, pady=5)
        self.frame_layers.pack_propagate(False)
        
        ctk.CTkLabel(self.frame_layers, text="LAYERS", font=("", 12, "bold"), text_color="#888").pack(pady=(15, 5))
        
        self.scroll_layers = PremiumScrollableFrame(self.frame_layers) # Scroll needed for unlimited layers
        self.scroll_layers.pack(fill="both", expand=True, padx=5, pady=5)
        
        # Theme Button (No fg_color arg = Default Blue)
        self.btn_add_layer = ctk.CTkButton(self.frame_layers, text="+ Add New Layer", height=32, command=self.add_layer)
        self.btn_add_layer.pack(pady=5, padx=10, fill="x")
        
        # Presets (Moved to Left)
        self.create_presets_menu(self.frame_layers)
        
        # --- CENTER PANEL: Preview ---
        self.frame_preview = ctk.CTkFrame(self.main_frame, fg_color="#1e1e1e")
        self.frame_preview.grid(row=0, column=1, sticky="nsew", padx=5, pady=5)
        
        self.lbl_preview = ctk.CTkLabel(self.frame_preview, text="")
        self.lbl_preview.pack(fill="both", expand=True)
        
        # Center Toolbar
        self.toolbar = ctk.CTkFrame(self.frame_preview, height=40, fg_color="#2b2b2b", corner_radius=10)
        self.toolbar.pack(side="bottom", fill="x", padx=10, pady=10)
        
        ctk.CTkLabel(self.toolbar, text="FX:", font=("", 11, "bold"), text_color="#888").pack(side="left", padx=10)
        
        self.var_global_inv = ctk.BooleanVar(value=False)
        ctk.CTkCheckBox(self.toolbar, text="Invert", variable=self.var_global_inv, command=self.request_render, width=60).pack(side="left", padx=5)
        
        self.var_normal = ctk.BooleanVar(value=False)
        ctk.CTkCheckBox(self.toolbar, text="Normal", variable=self.var_normal, command=self.on_normal_toggle, width=60).pack(side="left", padx=5)
        
        self.frame_normal_opts = ctk.CTkFrame(self.toolbar, fg_color="transparent")
        self.var_n_str = ctk.DoubleVar(value=1.0)
        ctk.CTkSlider(self.frame_normal_opts, from_=0.1, to=5.0, variable=self.var_n_str, width=60, command=lambda v: self.request_render()).pack(side="left", padx=5)
        self.check_flip_g = ctk.BooleanVar(value=False)
        ctk.CTkCheckBox(self.frame_normal_opts, text="Flip G", variable=self.check_flip_g, command=self.request_render, width=60).pack(side="left", padx=5)
        
        ctk.CTkFrame(self.toolbar, width=1, height=20, fg_color="#555").pack(side="left", padx=10)

        # Compact Sliders
        ctk.CTkLabel(self.toolbar, text="Thermal", font=("", 10)).pack(side="left", padx=2)
        self.var_erosion = ctk.IntVar(value=0)
        ctk.CTkSlider(self.toolbar, from_=0, to=50, number_of_steps=50, variable=self.var_erosion, width=70, height=14, command=lambda v: self.request_render()).pack(side="left", padx=2)

        ctk.CTkLabel(self.toolbar, text="Hydro", font=("", 10)).pack(side="left", padx=(10, 2))
        self.var_hydro = ctk.IntVar(value=0)
        ctk.CTkSlider(self.toolbar, from_=0, to=50, number_of_steps=50, variable=self.var_hydro, width=70, height=14, command=lambda v: self.request_render()).pack(side="left", padx=2)

        # --- RIGHT PANEL: Properties (No Scroll) ---
        self.frame_props = ctk.CTkFrame(self.main_frame, width=340)
        self.frame_props.grid(row=0, column=2, sticky="ns", padx=5, pady=5)
        self.frame_props.pack_propagate(False) # Strict logic
        
        ctk.CTkLabel(self.frame_props, text="PROPERTIES", font=("", 12, "bold"), text_color="#888").pack(pady=(15,5))
        
        # Container for props (Standard Frame)
        self.props_container = ctk.CTkFrame(self.frame_props, fg_color="transparent")
        self.props_container.pack(fill="both", expand=True, padx=5, pady=5)
        
        # Footer (Save/Res)
        self.frame_footer = ctk.CTkFrame(self.frame_props, fg_color="transparent")
        self.frame_footer.pack(side="bottom", fill="x", padx=10, pady=10)
        
        ctk.CTkLabel(self.frame_footer, text="Res:", font=("", 11, "bold"), text_color="#888").pack(side="left", padx=(0,5))
        self.var_res = ctk.StringVar(value="256")
        ctk.CTkOptionMenu(self.frame_footer, values=["256", "512", "1024"], variable=self.var_res, width=70, 
                         command=self.update_resolution).pack(side="left")

        ctk.CTkButton(self.frame_footer, text="üîç", width=30, height=30, fg_color="#444", 
                     command=self.open_hd_preview).pack(side="left", padx=5)
        
        # Theme Button (No fg_color arg = Default Blue)
        self.btn_save = ctk.CTkButton(self.frame_footer, text="Save Image", command=self.save_image, height=32, font=("", 13, "bold"))
        self.btn_save.pack(side="left", fill="x", expand=True, padx=(5,0))
        
    def create_presets_menu(self, parent):
        presets = ["Default"]
        preset_file = CONFIG_DIR / "presets" / "noise_master.json"
        
        self.preset_data = {}
        if preset_file.exists():
            try:
                with open(preset_file, 'r') as f:
                    self.preset_data = json.load(f)
                    presets.extend(self.preset_data.keys())
            except: pass
            
        self.var_preset = ctk.StringVar(value="Add Preset...")
        self.opt_preset = ctk.CTkOptionMenu(parent, values=presets, variable=self.var_preset, width=200, command=self.load_preset)
        self.opt_preset.pack(side="bottom", fill="x", padx=10, pady=(0, 10))

    def refresh_layer_list(self):
        for w in self.scroll_layers.winfo_children(): w.destroy()
        
        for i, layer in enumerate(self.layers):
            item = LayerItem(self.scroll_layers, layer, self.on_layer_change, self.delete_layer, i)
            item.pack(fill="x", pady=2)
            item.set_selected(i == self.selected_layer_index)

    def on_layer_change(self, index, selected=False):
        if selected:
            self.selected_layer_index = index
            self.refresh_layer_list()
            self.update_properties_panel()
        self.request_render()

    def add_layer(self):
        self.layers.insert(0, {'name': 'New Layer', 'type': 'perlin', 'scale_x': 5.0, 'scale_y': 5.0, 'octaves': 2, 'persistence': 0.5, 'visible': True, 'blend_mode': 'add'})
        self.selected_layer_index = 0
        self.refresh_layer_list()
        self.update_properties_panel()
        self.request_render()

    def delete_layer(self, index):
        if len(self.layers) <= 1: return
        del self.layers[index]
        self.selected_layer_index = max(0, min(self.selected_layer_index, len(self.layers)-1))
        self.refresh_layer_list()
        self.update_properties_panel()
        self.request_render()

    def load_preset(self, name):
        if name in self.preset_data:
            new_layers = self.preset_data[name]
            for l in new_layers:
                l = l.copy()
                if 'scale' in l and 'scale_x' not in l:
                    l['scale_x'] = l['scale']
                    l['scale_y'] = l['scale']
                if 'visible' not in l: l['visible'] = True
                if 'blend_mode' not in l: l['blend_mode'] = 'normal'
                self.layers.append(l) 
            self.selected_layer_index = len(self.layers) - len(new_layers)
            self.refresh_layer_list()
            self.update_properties_panel()
            self.request_render()
            self.var_preset.set("Add Preset...")

    # --- GRID BASED PROPERTIES PANEL ---
    def update_properties_panel(self):
        for w in self.props_container.winfo_children(): w.destroy()
        
        if self.selected_layer_index < 0 or self.selected_layer_index >= len(self.layers):
            return
            
        layer = self.layers[self.selected_layer_index]
        
        # Grid Helper (Compact)
        def add_row(parent, label_text, row_idx):
            lbl = ctk.CTkLabel(parent, text=label_text, font=("", 11), text_color="#ccc", anchor="w")
            lbl.grid(row=row_idx, column=0, sticky="w", padx=10, pady=2) # Compact Pady
            f = ctk.CTkFrame(parent, fg_color="transparent")
            f.grid(row=row_idx, column=1, sticky="ew", padx=10, pady=2)
            return f

        def add_header(text):
            f = ctk.CTkFrame(self.props_container, height=20, fg_color="transparent")
            f.pack(fill="x", padx=5, pady=(10, 2))
            ctk.CTkLabel(f, text=text, font=("", 10, "bold"), text_color="#666").pack(side="left")
            ctk.CTkFrame(f, height=1, fg_color="#333").pack(side="left", fill="x", expand=True, padx=5)

        # 1. GENERAL
        add_header("GENERAL")
        grid_gen = ctk.CTkFrame(self.props_container, fg_color="transparent")
        grid_gen.pack(fill="x")
        grid_gen.grid_columnconfigure(1, weight=1)
        
        r = add_row(grid_gen, "Name", 0)
        name_var = ctk.StringVar(value=layer.get('name', 'Layer'))
        ent = ctk.CTkEntry(r, textvariable=name_var, height=22)
        ent.pack(fill="x")
        ent.bind("<FocusOut>", lambda e: (layer.update({'name': name_var.get()}), self.refresh_layer_list()))
        ent.bind("<Return>", lambda e: (layer.update({'name': name_var.get()}), self.focus()))

        r = add_row(grid_gen, "Type", 1)
        type_var = ctk.StringVar(value=layer.get('type', 'perlin'))
        ctk.CTkOptionMenu(r, values=['perlin', 'simplex', 'cellular', 'voronoi', 'grad_linear', 'grad_radial', 'brick', 'checker', 'grid', 'dots', 'magic', 'circle', 'rect'], variable=type_var, width=110, height=22,
                         command=lambda v: self.update_layer_prop('type', v)).pack(side="left")
        
        ctk.CTkButton(r, text="üé≤", width=22, height=22, fg_color="#444", 
                     command=lambda: self.randomize_seed(layer)).pack(side="left", padx=5)

        r = add_row(grid_gen, "Opacity", 2)
        op_var = ctk.DoubleVar(value=layer.get('opacity', 1.0))
        ctk.CTkSlider(r, from_=0.0, to=1.0, variable=op_var, height=14,
                     command=lambda v: (layer.update({'opacity': v}), self.request_render())).pack(side="left", fill="x", expand=True)
        ctk.CTkLabel(r, text=f"{op_var.get():.0%}", font=("Monospace", 10), width=30).pack(side="right")

        # 2. TRANSFORM
        add_header("TRANSFORM")
        grid_trans = ctk.CTkFrame(self.props_container, fg_color="transparent")
        grid_trans.pack(fill="x")
        grid_trans.grid_columnconfigure(1, weight=1)
        
        ctk.CTkCheckBox(grid_trans, text="Link X/Y", variable=self.var_link_scale, font=("", 10), width=60, checkbox_width=16, checkbox_height=16).grid(row=0, column=1, sticky="e", padx=10)

        # Scale X
        r = add_row(grid_trans, "Scale X", 1)
        val_x = float(layer.get('scale_x', layer.get('scale', 10.0)))
        layer['scale_x'] = val_x
        vx_var = ctk.DoubleVar(value=val_x)
        lx = ctk.CTkLabel(r, text=f"{val_x:.1f}", font=("Monospace", 10), width=35, anchor="e")
        lx.pack(side="right")
        
        def cb_sx(v):
            layer['scale_x'] = v
            lx.configure(text=f"{v:.1f}")
            if self.var_link_scale.get():
                layer['scale_y'] = v
                if hasattr(self, 'vy_var'): self.vy_var.set(v)
                if hasattr(self, 'ly'): self.ly.configure(text=f"{v:.1f}")
            self.request_render()
        ctk.CTkSlider(r, from_=1.0, to=100.0, variable=vx_var, height=14, command=cb_sx).pack(side="left", fill="x", expand=True)

        # Scale Y
        r = add_row(grid_trans, "Scale Y", 2)
        val_y = float(layer.get('scale_y', layer.get('scale', 10.0)))
        layer['scale_y'] = val_y
        vy_var = ctk.DoubleVar(value=val_y)
        self.vy_var = vy_var
        ly = ctk.CTkLabel(r, text=f"{val_y:.1f}", font=("Monospace", 10), width=35, anchor="e")
        self.ly = ly 
        ly.pack(side="right")
        
        def cb_sy(v):
            layer['scale_y'] = v
            ly.configure(text=f"{v:.1f}")
            if self.var_link_scale.get():
                layer['scale_x'] = v
            self.request_render()
        ctk.CTkSlider(r, from_=1.0, to=100.0, variable=vy_var, height=14, command=cb_sy).pack(side="left", fill="x", expand=True)

        # Projection
        r = add_row(grid_trans, "Proj", 3)
        proj_var = ctk.StringVar(value=layer.get('projection', 'planar'))
        ctk.CTkOptionMenu(r, values=['planar', 'polar'], variable=proj_var, width=80, height=20, font=("", 10),
                         command=lambda v: self.update_layer_prop('projection', v)).pack(side="left")

        # 3. SETTINGS
        add_header("SETTINGS")
        grid_set = ctk.CTkFrame(self.props_container, fg_color="transparent")
        grid_set.pack(fill="x")
        grid_set.grid_columnconfigure(1, weight=1)

        r = add_row(grid_set, "Mask", 0)
        clip_var = ctk.BooleanVar(value=layer.get('clip', False))
        ctk.CTkCheckBox(r, text="Clip", variable=clip_var, font=("", 11), width=60, checkbox_width=16, checkbox_height=16,
                       command=lambda: self.update_layer_prop('clip', clip_var.get())).pack(side="left")

        r = add_row(grid_set, "Effect", 1)
        inv_var = ctk.BooleanVar(value=layer.get('invert', False))
        ctk.CTkCheckBox(r, text="Inv", variable=inv_var, width=50, checkbox_width=16, checkbox_height=16, font=("", 11),
                       command=lambda: self.update_layer_prop('invert', inv_var.get())).pack(side="left")
        rid_var = ctk.BooleanVar(value=layer.get('ridged', False))
        ctk.CTkCheckBox(r, text="Ridged", variable=rid_var, width=50, checkbox_width=16, checkbox_height=16, font=("", 11),
                       command=lambda: self.update_layer_prop('ridged', rid_var.get())).pack(side="left", padx=5)

        r = add_row(grid_set, "Warp", 2)
        warp_val = layer.get('distortion', 0.0)
        w_var = ctk.DoubleVar(value=warp_val)
        ctk.CTkSlider(r, from_=0.0, to=1.0, variable=w_var, height=14,
                     command=lambda v: (layer.update({'distortion': v}), self.request_render())).pack(side="left", fill="x", expand=True)

        # 4. DETAILS
        # 4. DETAILS
        l_type = layer.get('type')
        if l_type in ['perlin', 'simplex', 'grad_linear', 'grad_radial', 'brick', 'grid', 'dots', 'magic', 'circle', 'rect']:
            add_header("DETAILS")
            grid_det = ctk.CTkFrame(self.props_container, fg_color="transparent")
            grid_det.pack(fill="x")
            grid_det.grid_columnconfigure(1, weight=1)

            def add_detail_slider(txt, key, f, t, stp, idx):
                r = add_row(grid_det, txt, idx)
                val = layer.get(key, 0)
                v_var = ctk.DoubleVar(value=val)
                lbl = ctk.CTkLabel(r, text=f"{val:.2f}", width=35, font=("Monospace", 10), anchor="e")
                lbl.pack(side="right")
                
                def cb(v):
                    layer[key] = v
                    lbl.configure(text=f"{v:.2f}")
                    self.request_render()
                ctk.CTkSlider(r, from_=f, to=t, number_of_steps=(t-f)/stp, variable=v_var, height=14, command=cb).pack(side="left", fill="x", expand=True)

            if l_type in ['perlin', 'simplex']:
                add_detail_slider("Octave", 'octaves', 1, 8, 1, 0)
                add_detail_slider("Persist", 'persistence', 0.0, 1.0, 0.05, 1)
                add_detail_slider("Lacunar", 'lacunarity', 1.0, 4.0, 0.1, 2)
            elif l_type == 'grad_linear':
                add_detail_slider("Decay", 'persistence', 0.0, 1.0, 0.05, 1)
                add_detail_slider("Angle", 'lacunarity', 0, 360, 5, 2)
            elif l_type == 'grad_radial':
                add_detail_slider("Decay", 'persistence', 0.0, 1.0, 0.05, 1)
                add_detail_slider("Angle", 'lacunarity', 0, 360, 5, 2)
            elif l_type == 'brick':
                add_detail_slider("Mortar", 'persistence', 0.0, 1.0, 0.05, 0)
            elif l_type == 'grid':
                add_detail_slider("Thick", 'persistence', 0.0, 1.0, 0.05, 0)
            elif l_type == 'dots':
                add_detail_slider("Radius", 'persistence', 0.0, 1.0, 0.05, 0)
            elif l_type == 'magic':
                add_detail_slider("Depth", 'octaves', 1, 10, 1, 0)
                add_detail_slider("Chaos", 'persistence', 0.0, 1.0, 0.05, 1)
            elif l_type in ['circle', 'rect']:
                add_detail_slider("Hardness", 'persistence', 0.0, 1.0, 0.05, 0)

    def update_layer_prop(self, key, val):
        layer = self.layers[self.selected_layer_index]
        layer[key] = val
        if key == 'type': self.update_properties_panel()
        self.request_render()

    def randomize_seed(self, layer):
        import random
        layer['seed'] = random.randint(0, 9999)
        self.update_properties_panel()
        self.request_render()

    def on_normal_toggle(self):
        self.normal_mode = self.var_normal.get()
        if self.normal_mode:
            self.frame_normal_opts.pack(side="left", padx=10)
        else:
            self.frame_normal_opts.pack_forget()
        self.request_render()

    def open_hd_preview(self):
        # Create Toplevel
        top = ctk.CTkToplevel(self)
        top.title("HD Preview (1024x1024)")
        top.geometry("1040x1060")
        top.attributes("-topmost", True)
        
        lbl_loading = ctk.CTkLabel(top, text="Rendering 1024x1024...", font=("", 20))
        lbl_loading.pack(expand=True)
        
        lbl_img = ctk.CTkLabel(top, text="")
        
        # Capture current state
        layers = [dict(l) for l in self.layers]
        do_normal = self.var_normal.get()
        strength = self.var_n_str.get()
        flip_g = self.check_flip_g.get()
        global_inv = self.var_global_inv.get()
        erosion = self.var_erosion.get()
        hydro = self.var_hydro.get()
        rain = 0.01 # Fixed for now or grab from somewhere if we add rain slider
        
        def _render():
            # Temp Engine
            tmp_eng = NoiseEngine(1024, 1024)
            raw = tmp_eng.generate(layers, erosion_iter=erosion, hydro_iter=hydro, hydro_rain=rain)
            
            if global_inv: raw = 1.0 - raw
            
            if do_normal:
                norm = tmp_eng.generate_normal_map(raw, strength, flip_g)
                img = Image.fromarray((norm * 255).astype(np.uint8), mode='RGB')
            else:
                img = tmp_eng.to_image(raw)
                
            ctk_img = ctk.CTkImage(img, size=(1024, 1024))
            
            def _show():
                lbl_loading.destroy()
                lbl_img.configure(image=ctk_img)
                lbl_img.pack()
                
            top.after(0, _show)
            
        threading.Thread(target=_render, daemon=True).start()

    def update_resolution(self, val):
        size = int(val)
        self.engine.width = size
        self.engine.height = size
        self.request_render()

    def request_render(self):
        if self.debounce_timer:
            self.after_cancel(self.debounce_timer)
        self.debounce_timer = self.after(50, self.render_async)
        
    def render_async(self):
        layers = [dict(l) for l in self.layers]
        do_normal = self.var_normal.get()
        strength = self.var_n_str.get()
        flip_g = self.check_flip_g.get()
        global_inv = self.var_global_inv.get()
        erosion = self.var_erosion.get()
        hydro = self.var_hydro.get()
        
        def _job():
            raw_buffer = self.engine.generate(layers, erosion_iter=erosion, hydro_iter=hydro)
            if global_inv: raw_buffer = 1.0 - raw_buffer
            
            if do_normal:
                norm_map = self.engine.generate_normal_map(raw_buffer, strength, flip_g)
                preview_img = Image.fromarray((norm_map * 255).astype(np.uint8), mode='RGB')
                self.after(0, lambda: self.show_result(norm_map, preview_img, is_normal=True))
            else:
                img = self.engine.to_image(raw_buffer)
                self.after(0, lambda: self.show_result(raw_buffer, img, is_normal=False))
                
        threading.Thread(target=_job, daemon=True).start()
        
    def show_result(self, raw, img, is_normal=False):
        self.preview_buffer = raw
        self.preview_is_normal = is_normal
        ctk_img = ctk.CTkImage(img, size=(512, 512))
        self.lbl_preview.configure(image=ctk_img, text="")
        
    def save_image(self):
        if self.preview_buffer is None: return
        from tkinter import filedialog
        default_name = "normal_map" if getattr(self, 'preview_is_normal', False) else "noise_map"
        path = filedialog.asksaveasfilename(initialfile=default_name, defaultextension=".png", 
            filetypes=[("PNG 16-bit", "*.png"), ("PNG 8-bit", "*.png"), ("EXR 32-bit", "*.exr")])
        if not path: return
        save_path = Path(path)
        
        try:
            data = self.preview_buffer
            params = {'is_rgb': (data.ndim==3 and data.shape[2]==3), 'ext': save_path.suffix.lower()}
            
            if params['ext'] == '.exr' and OpenEXR:
                header = OpenEXR.Header(data.shape[1], data.shape[0])
                if params['is_rgb']:
                    header['channels'] = {'R': Imath.Channel(Imath.PixelType(Imath.PixelType.FLOAT)), 'G': Imath.Channel(Imath.PixelType(Imath.PixelType.FLOAT)), 'B': Imath.Channel(Imath.PixelType(Imath.PixelType.FLOAT))}
                    OpenEXR.OutputFile(str(save_path), header).writePixels({'R': data[:,:,0].astype(np.float32).tobytes(), 'G': data[:,:,1].astype(np.float32).tobytes(), 'B': data[:,:,2].astype(np.float32).tobytes()})
                else:
                    header['channels'] = {'Y': Imath.Channel(Imath.PixelType(Imath.PixelType.FLOAT))}
                    OpenEXR.OutputFile(str(save_path), header).writePixels({'Y': data.astype(np.float32).tobytes()})
            else:
                if params['is_rgb']: Image.fromarray((data * 255).astype(np.uint8), mode='RGB').save(save_path)
                else: Image.fromarray(self.engine.to_16bit(data), mode='I;16').save(save_path)
            messagebox.showinfo("Saved", f"Saved to {save_path.name}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed: {e}")

if __name__ == "__main__":
    app = NoiseMasterWindow()
    app.mainloop()
